\chapter{Исследовательский раздел}
\section{Технические характеристики}
Технические характеристики устройства, на котором выполнялось тестирование:
\begin{itemize}
	\item операционная система: Windows 10 Pro;
	\item память: 8 Гб;
	\item процессор: Intel(R) Core(TM) i5-8265U CPU @ 1.60 ГГц   1.80 ГГц.
\end{itemize}
Тестирование проводилось на ноутбуке, который был подключен к сети питания. Во время проведения тестирования ноутбук был нагружен только встроенными приложениями окружения, самим окружением и системой тестирования.

\section{Временные характеристики выполнения}
Проведено исследование времени работы алгоритмов от входных строк разной длины. Исходными данными были случайно сгенерированные строки длиной \{3, 4, 5, 6, 7, 8\}. Замеры были проведены 1000 раз и усреднены. Результат приведен на рисунке~\ref{fg:6_1}.
 
\begin{figure}[H]
	\hspace*{-1cm}
	\centering
	\begin{tikzpicture}
		\begin{axis}
			[grid = major,
			xlabel = Длина строки,
			ylabel = {Время, c},
			xmin = 3,% xmin=0
			width = 0.95\textwidth,
			height=0.5\textheight,
			xtick distance = 1,
			legend style={at={(0.5,-0.2)},anchor=north}]
			\addplot table{data/iterative_lev.txt};
			\addplot table{data/recursive_lev.txt};
			\addplot table{data/recursive_lev_matrix.txt};
			\addplot table{data/recursive_lev_damerau.txt};
			\legend{
				Итеративный алгоритм Левенштейна,
				Рекурсивный алгоритм Левенштейна без кэша,
				Рекурсивный алгоритм Левенштейна с матрицей,
				Рекурсивный алгоритм Дамерау~---~Левенштейна
			};
		\end{axis}
	\end{tikzpicture}
	\caption{График зависимости времени работы алгоритмов } 
	\label{fg:6_1}
\end{figure} 

По результатам рекурсивный алгоритм Левенштейна без кэша и алгоритм Дамерау~---~Левенштейна уступают по скорости выполнения, начиная уже со строки длиной 7. Рекурсивный алгоритм Левенштейна выигрывает по времени выполнения у реализации с матрицей для длины строк 7, 8 на 313\%, 1369\% соответственно. Рекурсивный алгоритм Дамерау~---~Левенштейна выполняется медленнее реализации без кэша для длины строк 7, 8 на 337\%, 1580\% соответственно, поскольку в нем задействуется дополнительная операция -- транспозиция, которая приводит к вызову рекурсии. За 100\% был взят итеративный алгоритм Левенштейна.

Выполнен анализ алгоритмов Левенштейна, итеративного и рекурсивного с использованием кэша, на значения входных строк длиной \{25, 50, 75, 100, 125, 150\}. Получен следующий результат, представленный на рисунке~\ref{fg:6_2}.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}
			[grid = major,
			xlabel = Длина строки,
			ylabel = {Время, c},
			xmin = 25,
			width = 0.95\textwidth,
			height=0.5\textheight,
			xtick distance = 25,
			legend style={at={(0.5,-0.2)},anchor=north}]
			\addplot table{data/iterative_lev_comp.txt};
			\addplot table{data/recursive_lev_matrix_comp.txt};
			\legend{
				Итеративный алгоритм Левенштейна,
				Рекурсивный алгоритм Левенштейна с матрицей
			};
		\end{axis}
	\end{tikzpicture}
	\caption{График зависимости времени работы алгоритмов нахождения расстояния} 
	\label{fg:6_2}
\end{figure} 

Рекурсивный алгоритм Левенштейна с использованием матрицы выигрывает по скорости у итеративного метода на длинах строк 50, 100, 150 примерно на 27\%, 31\%, 33\% соответственно. Это объясняется тем, что в итеративном случае выполняется дополнительная операция по обмену значений двух строк. На это требуется дополнительное время.

\section{Объем потребляемой памяти}
При исходных строках, длиною 3, требуется 52,8 Мб памяти. Результаты вызовов и объем потребляемой памяти приведены в таблице~\ref{table:ref2}:
\begin{table}[ht!]
	\centering
	\captionsetup{singlelinecheck = false, justification=raggedright}
	\caption{Число вызовов каждого алгоритма}
	\label{table:ref2}
	\begin{tabular}{|c|c|c|c|}
		\hline
		\multicolumn{3}{|c|}{Левенштейн} & Дамерау~---~Левенштейн \\ \cline{1-3} 
		\hline
		Итеративный & Рекурсивный & Рекурсивный & \multirow{2}{*}{Рекурсивный} \\
		с двумя строками & без кэша  & с матрицей & \\
		\hline
		1 & 94 & 28 & 94 \\ 
		\hline
	\end{tabular}
\end{table}\\
\\
Общее значение потребляемой памяти $S$ складывается по формуле (\ref{eq:4}).
\begin{equation}
	S = n_{calls} * V,
	\label{eq:4}
\end{equation}
где $n_{calls}$ - число вызовов функций, $V$ - объем памяти, занимаемый одним вызовом функции.

По результатам исследования памяти алгоритмы Левенштейна и Дамерау~---~Левенштейна потребляют больше памяти при выполнении по сравнению с другими (отличается от итеративного способа в 94 раз, от рекурсивного с \text{матрицей -- приблизительно} 3,35 раз).

\section*{Вывод}
Рекурсивный вызов Левенштейна без кэша и Дамерау~---~Левенштейна проигрывают как по скорости, так и по памяти итеративному. Hекурсивный алгоритм Левенштейна с матрицей выигрывает по скорости выполнения итеративному с двумя строками, но при этом проигрывает ему по памяти.

Сравнивая между собой рекурсивные вызовы алгоритмов Левенштейна и Дамерау~---~Левенштейна, сделан вывод о том, что рекуррентный алгоритм поиска расстояния Левенштейна с матрицей выигрывает как по времени, так и по памяти у других реализаций этих алгоритмов, а рекуррентный Дамерау~---~Левенштейн проигрывает им по обоим параметрам. Однако, стоит отметить, что в системах автоматического исправления текста, где чаще всего встречаются ошибки, связанные с транспозицией двух символов, выполнение исправления ошибок выбор алгоритма Дамерау~---~Левенштейна будет оптимальным решением.